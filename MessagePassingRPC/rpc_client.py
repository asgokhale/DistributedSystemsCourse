##############################################
#
# Author: Aniruddha Gokhale
#
# Created: Spring 2022
#
# Purpose: demonstrate a basic remote procedure call-based client
#
# A RPC uses message passing under the hood but provides a more
# type-safe and intuitive way for users to make invocations on the remote
# side because the caller makes invocations on methods (these could be methods
# of a class object, which is what we show here). That object often is
# a proxy of the real, remote implementation. The proxy simply offers the same
# interface to the caller. Under the hood, the proxy's method will then use the
# traditional message passing style where the packet is created in the
# desired format using some serialization framework like Flatbuffers etc 
#
##############################################

import argparse   # for argument parsing
import zmq  # ZeroMQ 

# define a proxy class for the server that supports the same interface
# as the real server. The client then invokes methods on this proxy, which
# are then sent to the other side. The proxy offers exactly the same interface
# to the caller as what the real implementation does on the remote side.
#
# Such proxies are also referred to as stubs and skeletons and are often
# automatically generated from interface and packet format definitions by
# interface definition language (IDL) compilers.  Although, in our implementation
# here, we show an extremely simple and manually created packet, one
# could use Flatbuffers or similar modern serialization framework to do the
# necessary packet serialization.
#
# Notice also that the only 3 methods one can invoke on this proxy are
# connect, get and put. Thus, it is impossible to send a wrong message type
# like "POST" as we did in the basic message passing client, or mess up the
# packet encoding by forgetting the space after the message type keyword
# because often the serialization code will be generated by frameworks like
# Flatbuffer
#
class ServerProxy ():

    # constructor
    def __init__ (self):
        # get the context and set the correct socket type
        self.context = zmq.Context ()
        self.socket = self.context.socket (zmq.REQ)

    def connect (self, args):
        connect_str = "tcp://" + args.ipaddr + ":" + args.port
        print ("Proxy::connect - Connecting to RPC server at {}".format (connect_str))
        self.socket.connect (connect_str)
        pass

    def get (self, key):
        # Note that we don't avoid creating the message but it gets
        # done here inside individual supported message type.
        # Moreover, often this code gets generated by an interface
        # definition language compiler and so the chance of making
        # a mistake is very low
        print ("Proxy::get - Sending a valid GET message")
        self.socket.send_string ("GET " + key)
        reply = self.socket.recv_string ()
        return reply   # return to the caller


    def put (self, key, value):
        # Note that we don't avoid creating the message but it gets
        # done here inside individual supported message type.
        # Moreover, often this code gets generated by an interface
        # definition language compiler and so the chance of making
        # a mistake is very low
        print ("Proxy::set - Sending a valid PUT message")
        self.socket.send_string ("PUT "+ key + " " + value)
        reply = self.socket.recv_string ()  # technically, this should be just an ack
        print ("Received reply = {}".format (reply))
    
###################################
#
# Parse command line arguments
#
###################################
def parseCmdLineArgs ():
    # instantiate a ArgumentParser object
    parser = argparse.ArgumentParser (description="Message Passing Client")

    # Now specify all the optional arguments we support

    # server's IP address
    parser.add_argument ("-a", "--ipaddr", default="localhost", help="IP address of the message passing server, default: localhost")

    # server's port
    parser.add_argument ("-p", "--port", default="5557", help="Port number used by message passing server, default: 5557")

    return parser.parse_args()


##################################
#
#  main program
#
##################################
def main ():
    # first parse the arguments
    print ("Main: parse command line arguments")
    args = parseCmdLineArgs ()

    print ("Current libzmq version is %s" % zmq.zmq_version())
    print ("Current  pyzmq version is %s" % zmq.__version__)
    
    print ("Initialize our server proxy")
    proxy = ServerProxy ()

    # Now create the right kind of socket
    print ("Connect the proxy to the real server")
    proxy.connect (args)

    # Now send messages using RPC
    #
    # Notice that we cannot make a mistake as we are bound by what the
    # interface supports so sending a wrong message like POST that we
    # did in the message passing example is not possible here.
    
    print ("Invoking the GET RPC")
    retval = proxy.get ("foo")
    print ("Value obtained from get call is {}".format (retval))

    print ("Invoking the PUT RPC")
    proxy.put ("foo", "bar")


###################################
#
# Main entry point
#
###################################
if __name__ == "__main__":
    main ()
    
